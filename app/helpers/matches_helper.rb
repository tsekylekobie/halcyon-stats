module MatchesHelper
	def jsonToMatchObject(os) # `os` is data pulled in OpenStruct format 
		# Organize OpenStruct into array of similar objects
		os[:data].map { |m| Match.new(m, os[:included]) }
	end

	def collectMatches(numOfMatches, gameMode, player)
		matches = {data: [], included: []}
		tStart = Time.new(2017, 01).utc.iso8601
		for i in (10..numOfMatches).step(10) do
			req = @client.matches({"filter[playerIds]" => player, "filter[gameMode]" => gameMode, "page[offset]" => i - 10, "filter[createdAt-start]" => tStart, "sort" => "-createdAt"})
			if req.success?
				response = JSON.parse(req.raw.body, object_class: OpenStruct)
				matches[:data] += response.data
				matches[:included] += response.included
			end
		end
		
		return jsonToMatchObject(matches)
	end

	def collectPlayerStats(playerIGN, matches) # `matches` is collection of Match objects, generated by jsonToMatchObject()
		heroesPlayed = Hash.new {|hash,key| hash[key]={wins: 0, losses: 0}}
		sideRecord = Hash.new {|hash,key| hash[key]={wins: 0, losses: 0}}
		aceTotal = 0.0
		krakenTotal = 0.0
		kills, assists, deaths = 0.0, 0.0, 0.0

		matches.each { |m| 
			m.teams.each { |t| 
				t.participants.each { |p|
					if p.player.ign == playerIGN
						aceTotal += t.acesEarned
						krakenTotal += t.krakenCaptures
						kills += p.kills
						assists += p.assists
						deaths += p.deaths
						if t.won
							sideRecord[t.side][:wins] += 1
							heroesPlayed[p.hero][:wins] += 1
						else
							sideRecord[t.side][:losses] += 1
							heroesPlayed[p.hero][:losses] += 1
						end
					end
				}
			}
		}

		return {:kills => kills, :assists => assists, :deaths => deaths, :heroesPlayed => heroesPlayed.sort_by {|k,v| v[:wins] + v[:losses]}.reverse, :averageAce => aceTotal / matches.length, :averageKraken => krakenTotal / matches.length, :sideRecord => sideRecord}
	end

	def calcWinPercentage(wins, losses, digits=0)
		"#{(100.0 * wins / (wins + losses)).round(digits)}%"
	end
end